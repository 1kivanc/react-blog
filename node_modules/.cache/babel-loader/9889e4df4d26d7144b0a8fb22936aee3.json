{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Toshiba\\\\Desktop\\\\odev\\\\odev\\\\src\\\\components\\\\Home\\\\Sliderss\\\\index.jsx\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\n/**\r\n * To prevent text selection while dragging.\r\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\r\n */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction pauseEvent(e) {\n  if (e && e.stopPropagation) {\n    e.stopPropagation();\n  }\n\n  if (e && e.preventDefault) {\n    e.preventDefault();\n  }\n\n  return false;\n}\n\nfunction stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n}\n\nfunction sanitizeInValue(x) {\n  if (x == null) {\n    return [];\n  }\n\n  return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n  return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = max - i * minDistance;\n\n    if (nextValue[length - 1 - i] > padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[length - 1 - i] = padding;\n    }\n  }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = min + i * minDistance;\n\n    if (nextValue[i] < padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[i] = padding;\n    }\n  }\n}\n\nfunction addHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.addEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction removeHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction trimAlignValue(val, props) {\n  return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n  const valModStep = (val - props.min) % props.step;\n  let alignedValue = val - valModStep;\n\n  if (Math.abs(valModStep) * 2 >= props.step) {\n    alignedValue += valModStep > 0 ? props.step : -props.step;\n  }\n\n  return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n  let trimmed = val;\n\n  if (trimmed <= props.min) {\n    trimmed = props.min;\n  }\n\n  if (trimmed >= props.max) {\n    trimmed = props.max;\n  }\n\n  return trimmed;\n}\n\nclass ReactSlider extends React.Component {\n  constructor(_props) {\n    super(_props);\n\n    this.onKeyUp = () => {\n      this.onEnd();\n    };\n\n    this.onMouseUp = () => {\n      this.onEnd(this.getMouseEventMap());\n    };\n\n    this.onTouchEnd = () => {\n      this.onEnd(this.getTouchEventMap());\n    };\n\n    this.onBlur = () => {\n      this.setState({\n        index: -1\n      }, this.onEnd(this.getKeyDownEventMap()));\n    };\n\n    this.onMouseMove = e => {\n      // Prevent controlled updates from happening while mouse is moving\n      this.setState({\n        pending: true\n      });\n      const position = this.getMousePosition(e);\n      const diffPosition = this.getDiffPosition(position[0]);\n      const newValue = this.getValueFromPosition(diffPosition);\n      this.move(newValue);\n    };\n\n    this.onTouchMove = e => {\n      if (e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      this.setState({\n        pending: true\n      });\n      const position = this.getTouchPosition(e);\n\n      if (typeof this.isScrolling === 'undefined') {\n        const diffMainDir = position[0] - this.startPosition[0];\n        const diffScrollDir = position[1] - this.startPosition[1];\n        this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n\n      if (this.isScrolling) {\n        this.setState({\n          index: -1\n        });\n        return;\n      }\n\n      const diffPosition = this.getDiffPosition(position[0]);\n      const newValue = this.getValueFromPosition(diffPosition);\n      this.move(newValue);\n    };\n\n    this.onKeyDown = e => {\n      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n        return;\n      } // Prevent controlled updates from happening while a key is pressed\n\n\n      this.setState({\n        pending: true\n      });\n\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowDown':\n        case 'Left':\n        case 'Down':\n          e.preventDefault();\n          this.moveDownByStep();\n          break;\n\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'Right':\n        case 'Up':\n          e.preventDefault();\n          this.moveUpByStep();\n          break;\n\n        case 'Home':\n          e.preventDefault();\n          this.move(this.props.min);\n          break;\n\n        case 'End':\n          e.preventDefault();\n          this.move(this.props.max);\n          break;\n\n        case 'PageDown':\n          e.preventDefault();\n          this.moveDownByStep(this.props.pageFn(this.props.step));\n          break;\n\n        case 'PageUp':\n          e.preventDefault();\n          this.moveUpByStep(this.props.pageFn(this.props.step));\n          break;\n\n        default:\n      }\n    };\n\n    this.onSliderMouseDown = e => {\n      // do nothing if disabled or right click\n      if (this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happening while mouse is moving\n\n\n      this.setState({\n        pending: true\n      });\n\n      if (!this.props.snapDragDisabled) {\n        const position = this.getMousePosition(e);\n        this.forceValueFromPosition(position[0], i => {\n          this.start(i, position[0]);\n          addHandlers(this.getMouseEventMap());\n        });\n      }\n\n      pauseEvent(e);\n    };\n\n    this.onSliderClick = e => {\n      if (this.props.disabled) {\n        return;\n      }\n\n      if (this.props.onSliderClick && !this.hasMoved) {\n        const position = this.getMousePosition(e);\n        const valueAtPos = trimAlignValue(this.calcValue(this.calcOffsetFromPosition(position[0])), this.props);\n        this.props.onSliderClick(valueAtPos);\n      }\n    };\n\n    this.createOnKeyDown = i => e => {\n      if (this.props.disabled) {\n        return;\n      }\n\n      this.start(i);\n      addHandlers(this.getKeyDownEventMap());\n      pauseEvent(e);\n    };\n\n    this.createOnMouseDown = i => e => {\n      // do nothing if disabled or right click\n      if (this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happending while mouse is moving\n\n\n      this.setState({\n        pending: true\n      });\n      const position = this.getMousePosition(e);\n      this.start(i, position[0]);\n      addHandlers(this.getMouseEventMap());\n      pauseEvent(e);\n    };\n\n    this.createOnTouchStart = i => e => {\n      if (this.props.disabled || e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      this.setState({\n        pending: true\n      });\n      const position = this.getTouchPosition(e);\n      this.startPosition = position; // don't know yet if the user is trying to scroll\n\n      this.isScrolling = undefined;\n      this.start(i, position[0]);\n      addHandlers(this.getTouchEventMap());\n      stopPropagation(e);\n    };\n\n    this.handleResize = () => {\n      // setTimeout of 0 gives element enough time to have assumed its new size if\n      // it is being resized\n      const resizeTimeout = window.setTimeout(() => {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        this.pendingResizeTimeouts.shift();\n        this.resize();\n      }, 0);\n      this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    this.renderThumb = (style, i) => {\n      const className = `${this.props.thumbClassName} ${this.props.thumbClassName}-${i} ${this.state.index === i ? this.props.thumbActiveClassName : ''}`;\n      const props = {\n        'ref': r => {\n          this[`thumb${i}`] = r;\n        },\n        'key': `${this.props.thumbClassName}-${i}`,\n        className,\n        style,\n        'onMouseDown': this.createOnMouseDown(i),\n        'onTouchStart': this.createOnTouchStart(i),\n        'onFocus': this.createOnKeyDown(i),\n        'tabIndex': 0,\n        'role': 'slider',\n        'aria-orientation': this.props.orientation,\n        'aria-valuenow': this.state.value[i],\n        'aria-valuemin': this.props.min,\n        'aria-valuemax': this.props.max,\n        'aria-label': Array.isArray(this.props.ariaLabel) ? this.props.ariaLabel[i] : this.props.ariaLabel,\n        'aria-labelledby': Array.isArray(this.props.ariaLabelledby) ? this.props.ariaLabelledby[i] : this.props.ariaLabelledby\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(this.state.value),\n        valueNow: this.state.value[i]\n      };\n\n      if (this.props.ariaValuetext) {\n        props['aria-valuetext'] = typeof this.props.ariaValuetext === 'string' ? this.props.ariaValuetext : this.props.ariaValuetext(state);\n      }\n\n      return this.props.renderThumb(props, state);\n    };\n\n    this.renderTrack = (i, offsetFrom, offsetTo) => {\n      const props = {\n        key: `${this.props.trackClassName}-${i}`,\n        className: `${this.props.trackClassName} ${this.props.trackClassName}-${i}`,\n        style: this.buildTrackStyle(offsetFrom, this.state.upperBound - offsetTo)\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(this.state.value)\n      };\n      return this.props.renderTrack(props, state);\n    };\n\n    let value = sanitizeInValue(_props.value);\n\n    if (!value.length) {\n      value = sanitizeInValue(_props.defaultValue);\n    } // array for storing resize timeouts ids\n\n\n    this.pendingResizeTimeouts = [];\n    const zIndices = [];\n\n    for (let i = 0; i < value.length; i += 1) {\n      value[i] = trimAlignValue(value[i], _props);\n      zIndices.push(i);\n    }\n\n    this.resizeObserver = null;\n    this.resizeElementRef = /*#__PURE__*/React.createRef();\n    this.state = {\n      index: -1,\n      upperBound: 0,\n      sliderLength: 0,\n      value,\n      zIndices\n    };\n  }\n\n  componentDidMount() {\n    if (typeof window !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResize);\n      this.resizeObserver.observe(this.resizeElementRef.current);\n      this.resize();\n    }\n  } // Keep the internal `value` consistent with an outside `value` if present.\n  // This basically allows the slider to be a controlled component.\n\n\n  static getDerivedStateFromProps(props, state) {\n    const value = sanitizeInValue(props.value);\n\n    if (!value.length) {\n      return null;\n    } // Do not allow controlled upates to happen while we have pending updates\n\n\n    if (state.pending) {\n      return null;\n    }\n\n    return {\n      value: value.map(item => trimAlignValue(item, props))\n    };\n  }\n\n  componentDidUpdate() {\n    // If an upperBound has not yet been determined (due to the component being hidden\n    // during the mount event, or during the last resize), then calculate it now\n    if (this.state.upperBound === 0) {\n      this.resize();\n    }\n  }\n\n  componentWillUnmount() {\n    this.clearPendingResizeTimeouts();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  }\n\n  onEnd(eventMap) {\n    if (eventMap) {\n      removeHandlers(eventMap);\n    }\n\n    if (this.hasMoved) {\n      this.fireChangeEvent('onAfterChange');\n    } // Allow controlled updates to continue\n\n\n    this.setState({\n      pending: false\n    });\n    this.hasMoved = false;\n  }\n\n  getValue() {\n    return prepareOutValue(this.state.value);\n  }\n\n  getClosestIndex(pixelOffset) {\n    let minDist = Number.MAX_VALUE;\n    let closestIndex = -1;\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      const offset = this.calcOffset(value[i]);\n      const dist = Math.abs(pixelOffset - offset);\n\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = i;\n      }\n    }\n\n    return closestIndex;\n  }\n\n  getMousePosition(e) {\n    return [e[`page${this.axisKey()}`], e[`page${this.orthogonalAxisKey()}`]];\n  }\n\n  getTouchPosition(e) {\n    const touch = e.touches[0];\n    return [touch[`page${this.axisKey()}`], touch[`page${this.orthogonalAxisKey()}`]];\n  }\n\n  getKeyDownEventMap() {\n    return {\n      keydown: this.onKeyDown,\n      keyup: this.onKeyUp,\n      focusout: this.onBlur\n    };\n  }\n\n  getMouseEventMap() {\n    return {\n      mousemove: this.onMouseMove,\n      mouseup: this.onMouseUp\n    };\n  }\n\n  getTouchEventMap() {\n    return {\n      touchmove: this.onTouchMove,\n      touchend: this.onTouchEnd\n    };\n  }\n\n  getValueFromPosition(position) {\n    const diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n    return trimAlignValue(this.state.startValue + diffValue, this.props);\n  }\n\n  getDiffPosition(position) {\n    let diffPosition = position - this.state.startPosition;\n\n    if (this.props.invert) {\n      diffPosition *= -1;\n    }\n\n    return diffPosition;\n  } // create the `keydown` handler for the i-th thumb\n\n\n  resize() {\n    const {\n      slider,\n      thumb0: thumb\n    } = this;\n\n    if (!slider || !thumb) {\n      return;\n    }\n\n    const sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders\n\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderSize = slider[sizeKey];\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders\n\n    const thumbRect = thumb.getBoundingClientRect();\n    const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n    const upperBound = sliderSize - thumbSize;\n    const sliderLength = Math.abs(sliderMax - sliderMin);\n\n    if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {\n      this.setState({\n        upperBound,\n        sliderLength,\n        thumbSize\n      });\n    }\n  } // calculates the offset of a thumb in pixels based on its value.\n\n\n  calcOffset(value) {\n    const range = this.props.max - this.props.min;\n\n    if (range === 0) {\n      return 0;\n    }\n\n    const ratio = (value - this.props.min) / range;\n    return ratio * this.state.upperBound;\n  } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n\n\n  calcValue(offset) {\n    const ratio = offset / this.state.upperBound;\n    return ratio * (this.props.max - this.props.min) + this.props.min;\n  }\n\n  calcOffsetFromPosition(position) {\n    const {\n      slider\n    } = this;\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.\n    // The slider bounding rect is based on the viewport, so we must add the window scroll\n    // offset to normalize the values.\n\n    const windowOffset = window[`page${this.axisKey()}Offset`];\n    const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n    let pixelOffset = position - sliderStart;\n\n    if (this.props.invert) {\n      pixelOffset = this.state.sliderLength - pixelOffset;\n    }\n\n    pixelOffset -= this.state.thumbSize / 2;\n    return pixelOffset;\n  } // Snaps the nearest thumb to the value corresponding to `position`\n  // and calls `callback` with that thumb's index.\n\n\n  forceValueFromPosition(position, callback) {\n    const pixelOffset = this.calcOffsetFromPosition(position);\n    const closestIndex = this.getClosestIndex(pixelOffset);\n    const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n\n    const value = this.state.value.slice();\n    value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n\n    for (let i = 0; i < value.length - 1; i += 1) {\n      if (value[i + 1] - value[i] < this.props.minDistance) {\n        return;\n      }\n    }\n\n    this.fireChangeEvent('onBeforeChange');\n    this.hasMoved = true;\n    this.setState({\n      value\n    }, () => {\n      callback(closestIndex);\n      this.fireChangeEvent('onChange');\n    });\n  } // clear all pending timeouts to avoid error messages after unmounting\n\n\n  clearPendingResizeTimeouts() {\n    do {\n      const nextTimeout = this.pendingResizeTimeouts.shift();\n      clearTimeout(nextTimeout);\n    } while (this.pendingResizeTimeouts.length);\n  }\n\n  start(i, position) {\n    const thumbRef = this[`thumb${i}`];\n\n    if (thumbRef) {\n      thumbRef.focus();\n    }\n\n    const {\n      zIndices\n    } = this.state; // remove wherever the element is\n\n    zIndices.splice(zIndices.indexOf(i), 1); // add to end\n\n    zIndices.push(i);\n    this.setState(prevState => ({\n      startValue: prevState.value[i],\n      startPosition: position !== undefined ? position : prevState.startPosition,\n      index: i,\n      zIndices\n    }));\n  }\n\n  moveUpByStep(step = this.props.step) {\n    const oldValue = this.state.value[this.state.index];\n    const newValue = trimAlignValue(oldValue + step, this.props);\n    this.move(Math.min(newValue, this.props.max));\n  }\n\n  moveDownByStep(step = this.props.step) {\n    const oldValue = this.state.value[this.state.index];\n    const newValue = trimAlignValue(oldValue - step, this.props);\n    this.move(Math.max(newValue, this.props.min));\n  }\n\n  move(newValue) {\n    const {\n      index,\n      value\n    } = this.state;\n    const {\n      length\n    } = value; // Short circuit if the value is not changing\n\n    const oldValue = value[index];\n\n    if (newValue === oldValue) {\n      return;\n    } // Trigger only before the first movement\n\n\n    if (!this.hasMoved) {\n      this.fireChangeEvent('onBeforeChange');\n    }\n\n    this.hasMoved = true; // if \"pearling\" (= thumbs pushing each other) is disabled,\n    // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n\n    const {\n      pearling,\n      max,\n      min,\n      minDistance\n    } = this.props;\n\n    if (!pearling) {\n      if (index > 0) {\n        const valueBefore = value[index - 1];\n\n        if (newValue < valueBefore + minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueBefore + minDistance;\n        }\n      }\n\n      if (index < length - 1) {\n        const valueAfter = value[index + 1];\n\n        if (newValue > valueAfter - minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueAfter - minDistance;\n        }\n      }\n    }\n\n    value[index] = newValue; // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n\n    if (pearling && length > 1) {\n      if (newValue > oldValue) {\n        this.pushSucceeding(value, minDistance, index);\n        trimSucceeding(length, value, minDistance, max);\n      } else if (newValue < oldValue) {\n        this.pushPreceding(value, minDistance, index);\n        trimPreceding(length, value, minDistance, min);\n      }\n    } // Normally you would use `shouldComponentUpdate`,\n    // but since the slider is a low-level component,\n    // the extra complexity might be worth the extra performance.\n\n\n    this.setState({\n      value\n    }, this.fireChangeEvent.bind(this, 'onChange'));\n  }\n\n  pushSucceeding(value, minDistance, index) {\n    let i;\n    let padding;\n\n    for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i + 1] = alignValue(padding, this.props);\n    }\n  }\n\n  pushPreceding(value, minDistance, index) {\n    for (let i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i - 1] = alignValue(padding, this.props);\n    }\n  }\n\n  axisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'Y';\n    } // Defaults to 'horizontal';\n\n\n    return 'X';\n  }\n\n  orthogonalAxisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'X';\n    } // Defaults to 'horizontal'\n\n\n    return 'Y';\n  }\n\n  posMinKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'bottom' : 'top';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'right' : 'left';\n  }\n\n  posMaxKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'top' : 'bottom';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'left' : 'right';\n  }\n\n  sizeKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'clientHeight';\n    } // Defaults to 'horizontal'\n\n\n    return 'clientWidth';\n  }\n\n  fireChangeEvent(event) {\n    if (this.props[event]) {\n      this.props[event](prepareOutValue(this.state.value), this.state.index);\n    }\n  }\n\n  buildThumbStyle(offset, i) {\n    const style = {\n      position: 'absolute',\n      touchAction: 'none',\n      willChange: this.state.index >= 0 ? this.posMinKey() : '',\n      zIndex: this.state.zIndices.indexOf(i) + 1\n    };\n    style[this.posMinKey()] = `${offset}px`;\n    return style;\n  }\n\n  buildTrackStyle(min, max) {\n    const obj = {\n      position: 'absolute',\n      willChange: this.state.index >= 0 ? `${this.posMinKey()},${this.posMaxKey()}` : ''\n    };\n    obj[this.posMinKey()] = min;\n    obj[this.posMaxKey()] = max;\n    return obj;\n  }\n\n  buildMarkStyle(offset) {\n    return {\n      position: 'absolute',\n      [this.posMinKey()]: offset\n    };\n  }\n\n  renderThumbs(offset) {\n    const {\n      length\n    } = offset;\n    const styles = [];\n\n    for (let i = 0; i < length; i += 1) {\n      styles[i] = this.buildThumbStyle(offset[i], i);\n    }\n\n    const res = [];\n\n    for (let i = 0; i < length; i += 1) {\n      res[i] = this.renderThumb(styles[i], i);\n    }\n\n    return res;\n  }\n\n  renderTracks(offset) {\n    const tracks = [];\n    const lastIndex = offset.length - 1;\n    tracks.push(this.renderTrack(0, 0, offset[0]));\n\n    for (let i = 0; i < lastIndex; i += 1) {\n      tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n    }\n\n    tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n    return tracks;\n  }\n\n  renderMarks() {\n    let {\n      marks\n    } = this.props;\n    const range = this.props.max - this.props.min + 1;\n\n    if (typeof marks === 'boolean') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key);\n    } else if (typeof marks === 'number') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key).filter(key => key % marks === 0);\n    }\n\n    return marks.map(parseFloat).sort((a, b) => a - b).map(mark => {\n      const offset = this.calcOffset(mark);\n      const props = {\n        key: mark,\n        className: this.props.markClassName,\n        style: this.buildMarkStyle(offset)\n      };\n      return this.props.renderMark(props);\n    });\n  }\n\n  render() {\n    const offset = [];\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      offset[i] = this.calcOffset(value[i], i);\n    }\n\n    const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n    const thumbs = this.renderThumbs(offset);\n    const marks = this.props.marks ? this.renderMarks() : null;\n    return /*#__PURE__*/React.createElement('div', {\n      ref: r => {\n        this.slider = r;\n        this.resizeElementRef.current = r;\n      },\n      style: {\n        position: 'relative'\n      },\n      className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n      onMouseDown: this.onSliderMouseDown,\n      onClick: this.onSliderClick\n    }, tracks, thumbs, marks);\n  }\n\n}\n\nReactSlider.displayName = 'ReactSlider';\nReactSlider.propTypes = {\n  /**\r\n   * The minimum value of the slider.\r\n   */\n  min: PropTypes.number,\n\n  /**\r\n   * The maximum value of the slider.\r\n   */\n  max: PropTypes.number,\n\n  /**\r\n   * Value to be added or subtracted on each step the slider makes.\r\n   * Must be greater than zero.\r\n   * `max - min` should be evenly divisible by the step value.\r\n   */\n  step: PropTypes.number,\n\n  /**\r\n   * The result of the function is the value to be added or subtracted\r\n   * when the `Page Up` or `Page Down` keys are pressed.\r\n   *\r\n   * The current `step` value will be passed as the only argument.\r\n   * By default, paging will modify `step` by a factor of 10.\r\n   */\n  pageFn: PropTypes.func,\n\n  /**\r\n   * The minimal distance between any pair of thumbs.\r\n   * Must be positive, but zero means they can sit on top of each other.\r\n   */\n  minDistance: PropTypes.number,\n\n  /**\r\n   * Determines the initial positions of the thumbs and the number of thumbs.\r\n   *\r\n   * If a number is passed a slider with one thumb will be rendered.\r\n   * If an array is passed each value will determine the position of one thumb.\r\n   * The values in the array must be sorted.\r\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n  /**\r\n   * Like `defaultValue` but for\r\n   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\r\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n  /**\r\n   * Determines whether the slider moves horizontally (from left to right)\r\n   * or vertically (from top to bottom).\r\n   */\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n  /**\r\n   * The css class set on the slider node.\r\n   */\n  className: PropTypes.string,\n\n  /**\r\n   * The css class set on each thumb node.\r\n   *\r\n   * In addition each thumb will receive a numbered css class of the form\r\n   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\r\n   */\n  thumbClassName: PropTypes.string,\n\n  /**\r\n   * The css class set on the thumb that is currently being moved.\r\n   */\n  thumbActiveClassName: PropTypes.string,\n\n  /**\r\n   * If `true` tracks between the thumbs will be rendered.\r\n   */\n  withTracks: PropTypes.bool,\n\n  /**\r\n   * The css class set on the tracks between the thumbs.\r\n   * In addition track fragment will receive a numbered css class of the form\r\n   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\r\n   */\n  trackClassName: PropTypes.string,\n\n  /**\r\n   * If `true` the active thumb will push other thumbs\r\n   * within the constraints of `min`, `max`, `step` and `minDistance`.\r\n   */\n  pearling: PropTypes.bool,\n\n  /**\r\n   * If `true` the thumbs can't be moved.\r\n   */\n  disabled: PropTypes.bool,\n\n  /**\r\n   * Disables thumb move when clicking the slider track\r\n   */\n  snapDragDisabled: PropTypes.bool,\n\n  /**\r\n   * Inverts the slider.\r\n   */\n  invert: PropTypes.bool,\n\n  /**\r\n   * Shows passed marks on the track, if true it shows all the marks,\r\n   * if an array of numbers it shows just the passed marks, if a number is passed\r\n   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\r\n   */\n  marks: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.bool, PropTypes.number]),\n\n  /**\r\n   * The css class set on the marks.\r\n   */\n  markClassName: PropTypes.string,\n\n  /**\r\n   * Callback called before starting to move a thumb. The callback will only be called if the\r\n   * action will result in a change. The function will be called with two arguments, the first\r\n   * being the initial value(s) the second being thumb index.\r\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onBeforeChange: PropTypes.func,\n\n  /**\r\n   * Callback called on every value change.\r\n   * The function will be called with two arguments, the first being the new value(s)\r\n   * the second being thumb index.\r\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onChange: PropTypes.func,\n\n  /**\r\n   * Callback called only after moving a thumb has ended. The callback will only be called if\r\n   * the action resulted in a change. The function will be called with two arguments, the\r\n   * first being the result value(s) the second being thumb index.\r\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onAfterChange: PropTypes.func,\n\n  /**\r\n   * Callback called when the the slider is clicked (thumb or tracks).\r\n   * Receives the value at the clicked position as argument.\r\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  onSliderClick: PropTypes.func,\n\n  /**\r\n   * aria-label for screen-readers to apply to the thumbs.\r\n   * Use an array for more than one thumb.\r\n   * The length of the array must match the number of thumbs in the value array.\r\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n  /**\r\n   * aria-labelledby for screen-readers to apply to the thumbs.\r\n   * Used when slider rendered with separate label.\r\n   * Use an array for more than one thumb.\r\n   * The length of the array must match the number of thumbs in the value array.\r\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabelledby: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n  /**\r\n   * aria-valuetext for screen-readers.\r\n   * Can be a static string, or a function that returns a string.\r\n   * The function will be passed a single argument,\r\n   * an object with the following properties:\r\n   *\r\n   *     state => `Value: ${state.value}`\r\n   *\r\n   * - `state.index` {`number`} the index of the thumb\r\n   * - `state.value` {`number` | `array`} the current value state\r\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\r\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaValuetext: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n\n  /**\r\n   * Provide a custom render function for the track node.\r\n   * The render function will be passed two arguments,\r\n   * an object with props that should be added to your handle node,\r\n   * and an object with track and slider state:\r\n   *\r\n   *     (props, state) => <div {...props} />\r\n   *\r\n   * - `props` {`object`} props to be spread into your track node\r\n   * - `state.index` {`number`} the index of the track\r\n   * - `state.value` {`number` | `array`} the current value state\r\n   */\n  renderTrack: PropTypes.func,\n\n  /**\r\n   * Provide a custom render function for dynamic thumb content.\r\n   * The render function will be passed two arguments,\r\n   * an object with props that should be added to your thumb node,\r\n   * and an object with thumb and slider state:\r\n   *\r\n   *     (props, state) => <div {...props} />\r\n   *\r\n   * - `props` {`object`} props to be spread into your thumb node\r\n   * - `state.index` {`number`} the index of the thumb\r\n   * - `state.value` {`number` | `array`} the current value state\r\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\r\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  renderThumb: PropTypes.func,\n\n  /**\r\n   * Provide a custom render function for the mark node.\r\n   * The render function will be passed one argument,\r\n   * an object with props that should be added to your handle node\r\n   *\r\n   *     (props) => <span {...props} />\r\n   *\r\n   * - `props` {`object`} props to be spread into your track node\r\n   */\n  renderMark: PropTypes.func\n};\nReactSlider.defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  pageFn: step => step * 10,\n  minDistance: 0,\n  defaultValue: 0,\n  orientation: 'horizontal',\n  className: 'slider',\n  thumbClassName: 'thumb',\n  thumbActiveClassName: 'active',\n  trackClassName: 'track',\n  markClassName: 'mark',\n  withTracks: true,\n  pearling: false,\n  disabled: false,\n  snapDragDisabled: false,\n  invert: false,\n  marks: [],\n  renderThumb: props => /*#__PURE__*/_jsxDEV(\"div\", { ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 353,\n    columnNumber: 31\n  }, ReactSlider),\n  renderTrack: props => /*#__PURE__*/_jsxDEV(\"div\", { ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 354,\n    columnNumber: 31\n  }, ReactSlider),\n  renderMark: props => /*#__PURE__*/_jsxDEV(\"span\", { ...props\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 355,\n    columnNumber: 30\n  }, ReactSlider)\n};\nexport default ReactSlider;","map":{"version":3,"sources":["C:/Users/Toshiba/Desktop/odev/odev/src/components/Home/Sliderss/index.jsx"],"names":["React","PropTypes","pauseEvent","e","stopPropagation","preventDefault","sanitizeInValue","x","Array","isArray","slice","prepareOutValue","length","trimSucceeding","nextValue","minDistance","max","i","padding","trimPreceding","min","addHandlers","eventMap","Object","keys","forEach","key","document","addEventListener","removeHandlers","removeEventListener","trimAlignValue","val","props","alignValue","trimValue","valModStep","step","alignedValue","Math","abs","parseFloat","toFixed","trimmed","ReactSlider","Component","constructor","onKeyUp","onEnd","onMouseUp","getMouseEventMap","onTouchEnd","getTouchEventMap","onBlur","setState","index","getKeyDownEventMap","onMouseMove","pending","position","getMousePosition","diffPosition","getDiffPosition","newValue","getValueFromPosition","move","onTouchMove","touches","getTouchPosition","isScrolling","diffMainDir","startPosition","diffScrollDir","onKeyDown","ctrlKey","shiftKey","altKey","metaKey","moveDownByStep","moveUpByStep","pageFn","onSliderMouseDown","disabled","button","snapDragDisabled","forceValueFromPosition","start","onSliderClick","hasMoved","valueAtPos","calcValue","calcOffsetFromPosition","createOnKeyDown","createOnMouseDown","createOnTouchStart","undefined","handleResize","resizeTimeout","window","setTimeout","pendingResizeTimeouts","shift","resize","push","renderThumb","style","className","thumbClassName","state","thumbActiveClassName","r","orientation","value","ariaLabel","ariaLabelledby","valueNow","ariaValuetext","renderTrack","offsetFrom","offsetTo","trackClassName","buildTrackStyle","upperBound","defaultValue","zIndices","resizeObserver","resizeElementRef","createRef","sliderLength","componentDidMount","ResizeObserver","observe","current","getDerivedStateFromProps","map","item","componentDidUpdate","componentWillUnmount","clearPendingResizeTimeouts","disconnect","fireChangeEvent","getValue","getClosestIndex","pixelOffset","minDist","Number","MAX_VALUE","closestIndex","l","offset","calcOffset","dist","axisKey","orthogonalAxisKey","touch","keydown","keyup","focusout","mousemove","mouseup","touchmove","touchend","diffValue","thumbSize","startValue","invert","slider","thumb0","thumb","sizeKey","sliderRect","getBoundingClientRect","sliderSize","sliderMax","posMaxKey","sliderMin","posMinKey","thumbRect","replace","toLowerCase","range","ratio","windowOffset","sliderStart","callback","nextTimeout","clearTimeout","thumbRef","focus","splice","indexOf","prevState","oldValue","pearling","valueBefore","valueAfter","pushSucceeding","pushPreceding","bind","event","buildThumbStyle","touchAction","willChange","zIndex","obj","buildMarkStyle","renderThumbs","styles","res","renderTracks","tracks","lastIndex","renderMarks","marks","from","_","filter","sort","a","b","mark","markClassName","renderMark","render","withTracks","thumbs","createElement","ref","onMouseDown","onClick","displayName","propTypes","number","func","oneOfType","arrayOf","oneOf","string","bool","onBeforeChange","onChange","onAfterChange","defaultProps"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n/**\r\n * To prevent text selection while dragging.\r\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\r\n */\r\nfunction pauseEvent(e) {\r\n    if (e && e.stopPropagation) {\r\n        e.stopPropagation();\r\n    }\r\n    if (e && e.preventDefault) {\r\n        e.preventDefault();\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction stopPropagation(e) {\r\n    if (e.stopPropagation) {\r\n        e.stopPropagation();\r\n    }\r\n}\r\n\r\nfunction sanitizeInValue(x) {\r\n    if (x == null) {\r\n        return [];\r\n    }\r\n    return Array.isArray(x) ? x.slice() : [x];\r\n}\r\n\r\nfunction prepareOutValue(x) {\r\n    return x !== null && x.length === 1 ? x[0] : x.slice();\r\n}\r\n\r\nfunction trimSucceeding(length, nextValue, minDistance, max) {\r\n    for (let i = 0; i < length; i += 1) {\r\n        const padding = max - i * minDistance;\r\n        if (nextValue[length - 1 - i] > padding) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            nextValue[length - 1 - i] = padding;\r\n        }\r\n    }\r\n}\r\n\r\nfunction trimPreceding(length, nextValue, minDistance, min) {\r\n    for (let i = 0; i < length; i += 1) {\r\n        const padding = min + i * minDistance;\r\n        if (nextValue[i] < padding) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            nextValue[i] = padding;\r\n        }\r\n    }\r\n}\r\n\r\nfunction addHandlers(eventMap) {\r\n    Object.keys(eventMap).forEach(key => {\r\n        if (typeof document !== 'undefined') {\r\n            document.addEventListener(key, eventMap[key], false);\r\n        }\r\n    });\r\n}\r\n\r\nfunction removeHandlers(eventMap) {\r\n    Object.keys(eventMap).forEach(key => {\r\n        if (typeof document !== 'undefined') {\r\n            document.removeEventListener(key, eventMap[key], false);\r\n        }\r\n    });\r\n}\r\n\r\nfunction trimAlignValue(val, props) {\r\n    return alignValue(trimValue(val, props), props);\r\n}\r\n\r\nfunction alignValue(val, props) {\r\n    const valModStep = (val - props.min) % props.step;\r\n    let alignedValue = val - valModStep;\r\n\r\n    if (Math.abs(valModStep) * 2 >= props.step) {\r\n        alignedValue += valModStep > 0 ? props.step : -props.step;\r\n    }\r\n\r\n    return parseFloat(alignedValue.toFixed(5));\r\n}\r\n\r\nfunction trimValue(val, props) {\r\n    let trimmed = val;\r\n    if (trimmed <= props.min) {\r\n        trimmed = props.min;\r\n    }\r\n    if (trimmed >= props.max) {\r\n        trimmed = props.max;\r\n    }\r\n\r\n    return trimmed;\r\n}\r\n\r\nclass ReactSlider extends React.Component {\r\n    static displayName = 'ReactSlider';\r\n\r\n    static propTypes = {\r\n        /**\r\n         * The minimum value of the slider.\r\n         */\r\n        min: PropTypes.number,\r\n\r\n        /**\r\n         * The maximum value of the slider.\r\n         */\r\n        max: PropTypes.number,\r\n\r\n        /**\r\n         * Value to be added or subtracted on each step the slider makes.\r\n         * Must be greater than zero.\r\n         * `max - min` should be evenly divisible by the step value.\r\n         */\r\n        step: PropTypes.number,\r\n\r\n        /**\r\n         * The result of the function is the value to be added or subtracted\r\n         * when the `Page Up` or `Page Down` keys are pressed.\r\n         *\r\n         * The current `step` value will be passed as the only argument.\r\n         * By default, paging will modify `step` by a factor of 10.\r\n         */\r\n        pageFn: PropTypes.func,\r\n\r\n        /**\r\n         * The minimal distance between any pair of thumbs.\r\n         * Must be positive, but zero means they can sit on top of each other.\r\n         */\r\n        minDistance: PropTypes.number,\r\n\r\n        /**\r\n         * Determines the initial positions of the thumbs and the number of thumbs.\r\n         *\r\n         * If a number is passed a slider with one thumb will be rendered.\r\n         * If an array is passed each value will determine the position of one thumb.\r\n         * The values in the array must be sorted.\r\n         */\r\n        defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\r\n\r\n        /**\r\n         * Like `defaultValue` but for\r\n         * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\r\n         */\r\n        // eslint-disable-next-line zillow/react/require-default-props\r\n        value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\r\n\r\n        /**\r\n         * Determines whether the slider moves horizontally (from left to right)\r\n         * or vertically (from top to bottom).\r\n         */\r\n        orientation: PropTypes.oneOf(['horizontal', 'vertical']),\r\n\r\n        /**\r\n         * The css class set on the slider node.\r\n         */\r\n        className: PropTypes.string,\r\n\r\n        /**\r\n         * The css class set on each thumb node.\r\n         *\r\n         * In addition each thumb will receive a numbered css class of the form\r\n         * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\r\n         */\r\n        thumbClassName: PropTypes.string,\r\n\r\n        /**\r\n         * The css class set on the thumb that is currently being moved.\r\n         */\r\n        thumbActiveClassName: PropTypes.string,\r\n\r\n        /**\r\n         * If `true` tracks between the thumbs will be rendered.\r\n         */\r\n        withTracks: PropTypes.bool,\r\n\r\n        /**\r\n         * The css class set on the tracks between the thumbs.\r\n         * In addition track fragment will receive a numbered css class of the form\r\n         * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\r\n         */\r\n        trackClassName: PropTypes.string,\r\n\r\n        /**\r\n         * If `true` the active thumb will push other thumbs\r\n         * within the constraints of `min`, `max`, `step` and `minDistance`.\r\n         */\r\n        pearling: PropTypes.bool,\r\n\r\n        /**\r\n         * If `true` the thumbs can't be moved.\r\n         */\r\n        disabled: PropTypes.bool,\r\n\r\n        /**\r\n         * Disables thumb move when clicking the slider track\r\n         */\r\n        snapDragDisabled: PropTypes.bool,\r\n\r\n        /**\r\n         * Inverts the slider.\r\n         */\r\n        invert: PropTypes.bool,\r\n\r\n        /**\r\n         * Shows passed marks on the track, if true it shows all the marks,\r\n         * if an array of numbers it shows just the passed marks, if a number is passed\r\n         * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\r\n         */\r\n        marks: PropTypes.oneOfType([\r\n            PropTypes.arrayOf(PropTypes.number),\r\n            PropTypes.bool,\r\n            PropTypes.number,\r\n        ]),\r\n\r\n        /**\r\n         * The css class set on the marks.\r\n         */\r\n        markClassName: PropTypes.string,\r\n\r\n        /**\r\n         * Callback called before starting to move a thumb. The callback will only be called if the\r\n         * action will result in a change. The function will be called with two arguments, the first\r\n         * being the initial value(s) the second being thumb index.\r\n         */\r\n        // eslint-disable-next-line max-len\r\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\r\n        onBeforeChange: PropTypes.func,\r\n\r\n        /**\r\n         * Callback called on every value change.\r\n         * The function will be called with two arguments, the first being the new value(s)\r\n         * the second being thumb index.\r\n         */\r\n        // eslint-disable-next-line max-len\r\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\r\n        onChange: PropTypes.func,\r\n\r\n        /**\r\n         * Callback called only after moving a thumb has ended. The callback will only be called if\r\n         * the action resulted in a change. The function will be called with two arguments, the\r\n         * first being the result value(s) the second being thumb index.\r\n         */\r\n        // eslint-disable-next-line max-len\r\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\r\n        onAfterChange: PropTypes.func,\r\n\r\n        /**\r\n         * Callback called when the the slider is clicked (thumb or tracks).\r\n         * Receives the value at the clicked position as argument.\r\n         */\r\n        // eslint-disable-next-line zillow/react/require-default-props\r\n        onSliderClick: PropTypes.func,\r\n\r\n        /**\r\n         * aria-label for screen-readers to apply to the thumbs.\r\n         * Use an array for more than one thumb.\r\n         * The length of the array must match the number of thumbs in the value array.\r\n         */\r\n        // eslint-disable-next-line zillow/react/require-default-props\r\n        ariaLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\r\n\r\n        /**\r\n         * aria-labelledby for screen-readers to apply to the thumbs.\r\n         * Used when slider rendered with separate label.\r\n         * Use an array for more than one thumb.\r\n         * The length of the array must match the number of thumbs in the value array.\r\n         */\r\n        // eslint-disable-next-line zillow/react/require-default-props\r\n        ariaLabelledby: PropTypes.oneOfType([\r\n            PropTypes.string,\r\n            PropTypes.arrayOf(PropTypes.string),\r\n        ]),\r\n\r\n        /**\r\n         * aria-valuetext for screen-readers.\r\n         * Can be a static string, or a function that returns a string.\r\n         * The function will be passed a single argument,\r\n         * an object with the following properties:\r\n         *\r\n         *     state => `Value: ${state.value}`\r\n         *\r\n         * - `state.index` {`number`} the index of the thumb\r\n         * - `state.value` {`number` | `array`} the current value state\r\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\r\n         */\r\n        // eslint-disable-next-line zillow/react/require-default-props\r\n        ariaValuetext: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\r\n\r\n        /**\r\n         * Provide a custom render function for the track node.\r\n         * The render function will be passed two arguments,\r\n         * an object with props that should be added to your handle node,\r\n         * and an object with track and slider state:\r\n         *\r\n         *     (props, state) => <div {...props} />\r\n         *\r\n         * - `props` {`object`} props to be spread into your track node\r\n         * - `state.index` {`number`} the index of the track\r\n         * - `state.value` {`number` | `array`} the current value state\r\n         */\r\n        renderTrack: PropTypes.func,\r\n\r\n        /**\r\n         * Provide a custom render function for dynamic thumb content.\r\n         * The render function will be passed two arguments,\r\n         * an object with props that should be added to your thumb node,\r\n         * and an object with thumb and slider state:\r\n         *\r\n         *     (props, state) => <div {...props} />\r\n         *\r\n         * - `props` {`object`} props to be spread into your thumb node\r\n         * - `state.index` {`number`} the index of the thumb\r\n         * - `state.value` {`number` | `array`} the current value state\r\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\r\n         */\r\n        // eslint-disable-next-line zillow/react/require-default-props\r\n        renderThumb: PropTypes.func,\r\n\r\n        /**\r\n         * Provide a custom render function for the mark node.\r\n         * The render function will be passed one argument,\r\n         * an object with props that should be added to your handle node\r\n         *\r\n         *     (props) => <span {...props} />\r\n         *\r\n         * - `props` {`object`} props to be spread into your track node\r\n         */\r\n        renderMark: PropTypes.func,\r\n    };\r\n\r\n    static defaultProps = {\r\n        min: 0,\r\n        max: 100,\r\n        step: 1,\r\n        pageFn: step => step * 10,\r\n        minDistance: 0,\r\n        defaultValue: 0,\r\n        orientation: 'horizontal',\r\n        className: 'slider',\r\n        thumbClassName: 'thumb',\r\n        thumbActiveClassName: 'active',\r\n        trackClassName: 'track',\r\n        markClassName: 'mark',\r\n        withTracks: true,\r\n        pearling: false,\r\n        disabled: false,\r\n        snapDragDisabled: false,\r\n        invert: false,\r\n        marks: [],\r\n        renderThumb: props => <div {...props} />,\r\n        renderTrack: props => <div {...props} />,\r\n        renderMark: props => <span {...props} />,\r\n    };\r\n\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        let value = sanitizeInValue(props.value);\r\n        if (!value.length) {\r\n            value = sanitizeInValue(props.defaultValue);\r\n        }\r\n\r\n        // array for storing resize timeouts ids\r\n        this.pendingResizeTimeouts = [];\r\n\r\n        const zIndices = [];\r\n        for (let i = 0; i < value.length; i += 1) {\r\n            value[i] = trimAlignValue(value[i], props);\r\n            zIndices.push(i);\r\n        }\r\n\r\n        this.resizeObserver = null;\r\n        this.resizeElementRef = React.createRef();\r\n\r\n        this.state = {\r\n            index: -1,\r\n            upperBound: 0,\r\n            sliderLength: 0,\r\n            value,\r\n            zIndices,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        if (typeof window !== 'undefined') {\r\n            this.resizeObserver = new ResizeObserver(this.handleResize);\r\n            this.resizeObserver.observe(this.resizeElementRef.current);\r\n            this.resize();\r\n        }\r\n    }\r\n\r\n    // Keep the internal `value` consistent with an outside `value` if present.\r\n    // This basically allows the slider to be a controlled component.\r\n    static getDerivedStateFromProps(props, state) {\r\n        const value = sanitizeInValue(props.value);\r\n        if (!value.length) {\r\n            return null;\r\n        }\r\n\r\n        // Do not allow controlled upates to happen while we have pending updates\r\n        if (state.pending) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            value: value.map(item => trimAlignValue(item, props)),\r\n        };\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        // If an upperBound has not yet been determined (due to the component being hidden\r\n        // during the mount event, or during the last resize), then calculate it now\r\n        if (this.state.upperBound === 0) {\r\n            this.resize();\r\n        }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this.clearPendingResizeTimeouts();\r\n        if (this.resizeObserver) {\r\n            this.resizeObserver.disconnect();\r\n        }\r\n    }\r\n\r\n    onKeyUp = () => {\r\n        this.onEnd();\r\n    };\r\n\r\n    onMouseUp = () => {\r\n        this.onEnd(this.getMouseEventMap());\r\n    };\r\n\r\n    onTouchEnd = () => {\r\n        this.onEnd(this.getTouchEventMap());\r\n    };\r\n\r\n    onBlur = () => {\r\n        this.setState({ index: -1 }, this.onEnd(this.getKeyDownEventMap()));\r\n    };\r\n\r\n    onEnd(eventMap) {\r\n        if (eventMap) {\r\n            removeHandlers(eventMap);\r\n        }\r\n        if (this.hasMoved) {\r\n            this.fireChangeEvent('onAfterChange');\r\n        }\r\n\r\n        // Allow controlled updates to continue\r\n        this.setState({ pending: false });\r\n\r\n        this.hasMoved = false;\r\n    }\r\n\r\n    onMouseMove = e => {\r\n        // Prevent controlled updates from happening while mouse is moving\r\n        this.setState({ pending: true });\r\n\r\n        const position = this.getMousePosition(e);\r\n        const diffPosition = this.getDiffPosition(position[0]);\r\n        const newValue = this.getValueFromPosition(diffPosition);\r\n        this.move(newValue);\r\n    };\r\n\r\n    onTouchMove = e => {\r\n        if (e.touches.length > 1) {\r\n            return;\r\n        }\r\n\r\n        // Prevent controlled updates from happending while touch is moving\r\n        this.setState({ pending: true });\r\n\r\n        const position = this.getTouchPosition(e);\r\n\r\n        if (typeof this.isScrolling === 'undefined') {\r\n            const diffMainDir = position[0] - this.startPosition[0];\r\n            const diffScrollDir = position[1] - this.startPosition[1];\r\n            this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\r\n        }\r\n\r\n        if (this.isScrolling) {\r\n            this.setState({ index: -1 });\r\n            return;\r\n        }\r\n\r\n        const diffPosition = this.getDiffPosition(position[0]);\r\n        const newValue = this.getValueFromPosition(diffPosition);\r\n\r\n        this.move(newValue);\r\n    };\r\n\r\n    onKeyDown = e => {\r\n        if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\r\n            return;\r\n        }\r\n\r\n        // Prevent controlled updates from happening while a key is pressed\r\n        this.setState({ pending: true });\r\n\r\n        switch (e.key) {\r\n            case 'ArrowLeft':\r\n            case 'ArrowDown':\r\n            case 'Left':\r\n            case 'Down':\r\n                e.preventDefault();\r\n                this.moveDownByStep();\r\n                break;\r\n            case 'ArrowRight':\r\n            case 'ArrowUp':\r\n            case 'Right':\r\n            case 'Up':\r\n                e.preventDefault();\r\n                this.moveUpByStep();\r\n                break;\r\n            case 'Home':\r\n                e.preventDefault();\r\n                this.move(this.props.min);\r\n                break;\r\n            case 'End':\r\n                e.preventDefault();\r\n                this.move(this.props.max);\r\n                break;\r\n            case 'PageDown':\r\n                e.preventDefault();\r\n                this.moveDownByStep(this.props.pageFn(this.props.step));\r\n                break;\r\n            case 'PageUp':\r\n                e.preventDefault();\r\n                this.moveUpByStep(this.props.pageFn(this.props.step));\r\n                break;\r\n            default:\r\n        }\r\n    };\r\n\r\n    onSliderMouseDown = e => {\r\n        // do nothing if disabled or right click\r\n        if (this.props.disabled || e.button === 2) {\r\n            return;\r\n        }\r\n\r\n        // Prevent controlled updates from happening while mouse is moving\r\n        this.setState({ pending: true });\r\n\r\n        if (!this.props.snapDragDisabled) {\r\n            const position = this.getMousePosition(e);\r\n            this.forceValueFromPosition(position[0], i => {\r\n                this.start(i, position[0]);\r\n                addHandlers(this.getMouseEventMap());\r\n            });\r\n        }\r\n\r\n        pauseEvent(e);\r\n    };\r\n\r\n    onSliderClick = e => {\r\n        if (this.props.disabled) {\r\n            return;\r\n        }\r\n\r\n        if (this.props.onSliderClick && !this.hasMoved) {\r\n            const position = this.getMousePosition(e);\r\n            const valueAtPos = trimAlignValue(\r\n                this.calcValue(this.calcOffsetFromPosition(position[0])),\r\n                this.props\r\n            );\r\n            this.props.onSliderClick(valueAtPos);\r\n        }\r\n    };\r\n\r\n    getValue() {\r\n        return prepareOutValue(this.state.value);\r\n    }\r\n\r\n    getClosestIndex(pixelOffset) {\r\n        let minDist = Number.MAX_VALUE;\r\n        let closestIndex = -1;\r\n\r\n        const { value } = this.state;\r\n        const l = value.length;\r\n\r\n        for (let i = 0; i < l; i += 1) {\r\n            const offset = this.calcOffset(value[i]);\r\n            const dist = Math.abs(pixelOffset - offset);\r\n            if (dist < minDist) {\r\n                minDist = dist;\r\n                closestIndex = i;\r\n            }\r\n        }\r\n\r\n        return closestIndex;\r\n    }\r\n\r\n    getMousePosition(e) {\r\n        return [e[`page${this.axisKey()}`], e[`page${this.orthogonalAxisKey()}`]];\r\n    }\r\n\r\n    getTouchPosition(e) {\r\n        const touch = e.touches[0];\r\n        return [touch[`page${this.axisKey()}`], touch[`page${this.orthogonalAxisKey()}`]];\r\n    }\r\n\r\n    getKeyDownEventMap() {\r\n        return {\r\n            keydown: this.onKeyDown,\r\n            keyup: this.onKeyUp,\r\n            focusout: this.onBlur,\r\n        };\r\n    }\r\n\r\n    getMouseEventMap() {\r\n        return {\r\n            mousemove: this.onMouseMove,\r\n            mouseup: this.onMouseUp,\r\n        };\r\n    }\r\n\r\n    getTouchEventMap() {\r\n        return {\r\n            touchmove: this.onTouchMove,\r\n            touchend: this.onTouchEnd,\r\n        };\r\n    }\r\n\r\n    getValueFromPosition(position) {\r\n        const diffValue =\r\n            (position / (this.state.sliderLength - this.state.thumbSize)) *\r\n            (this.props.max - this.props.min);\r\n        return trimAlignValue(this.state.startValue + diffValue, this.props);\r\n    }\r\n\r\n    getDiffPosition(position) {\r\n        let diffPosition = position - this.state.startPosition;\r\n        if (this.props.invert) {\r\n            diffPosition *= -1;\r\n        }\r\n        return diffPosition;\r\n    }\r\n\r\n    // create the `keydown` handler for the i-th thumb\r\n    createOnKeyDown = i => e => {\r\n        if (this.props.disabled) {\r\n            return;\r\n        }\r\n        this.start(i);\r\n        addHandlers(this.getKeyDownEventMap());\r\n        pauseEvent(e);\r\n    };\r\n\r\n    // create the `mousedown` handler for the i-th thumb\r\n    createOnMouseDown = i => e => {\r\n        // do nothing if disabled or right click\r\n        if (this.props.disabled || e.button === 2) {\r\n            return;\r\n        }\r\n\r\n        // Prevent controlled updates from happending while mouse is moving\r\n        this.setState({ pending: true });\r\n\r\n        const position = this.getMousePosition(e);\r\n        this.start(i, position[0]);\r\n        addHandlers(this.getMouseEventMap());\r\n        pauseEvent(e);\r\n    };\r\n\r\n    // create the `touchstart` handler for the i-th thumb\r\n    createOnTouchStart = i => e => {\r\n        if (this.props.disabled || e.touches.length > 1) {\r\n            return;\r\n        }\r\n\r\n        // Prevent controlled updates from happending while touch is moving\r\n        this.setState({ pending: true });\r\n\r\n        const position = this.getTouchPosition(e);\r\n        this.startPosition = position;\r\n        // don't know yet if the user is trying to scroll\r\n        this.isScrolling = undefined;\r\n        this.start(i, position[0]);\r\n        addHandlers(this.getTouchEventMap());\r\n        stopPropagation(e);\r\n    };\r\n\r\n    handleResize = () => {\r\n        // setTimeout of 0 gives element enough time to have assumed its new size if\r\n        // it is being resized\r\n        const resizeTimeout = window.setTimeout(() => {\r\n            // drop this timeout from pendingResizeTimeouts to reduce memory usage\r\n            this.pendingResizeTimeouts.shift();\r\n            this.resize();\r\n        }, 0);\r\n\r\n        this.pendingResizeTimeouts.push(resizeTimeout);\r\n    };\r\n\r\n    resize() {\r\n        const { slider, thumb0: thumb } = this;\r\n        if (!slider || !thumb) {\r\n            return;\r\n        }\r\n\r\n        const sizeKey = this.sizeKey();\r\n\r\n        // For the slider size, we want to use the client width/height, excluding any borders\r\n        const sliderRect = slider.getBoundingClientRect();\r\n        const sliderSize = slider[sizeKey];\r\n        const sliderMax = sliderRect[this.posMaxKey()];\r\n        const sliderMin = sliderRect[this.posMinKey()];\r\n\r\n        // For the thumb size, we want to use the outer width/height, including any borders\r\n        const thumbRect = thumb.getBoundingClientRect();\r\n        const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\r\n\r\n        const upperBound = sliderSize - thumbSize;\r\n        const sliderLength = Math.abs(sliderMax - sliderMin);\r\n\r\n        if (\r\n            this.state.upperBound !== upperBound ||\r\n            this.state.sliderLength !== sliderLength ||\r\n            this.state.thumbSize !== thumbSize\r\n        ) {\r\n            this.setState({\r\n                upperBound,\r\n                sliderLength,\r\n                thumbSize,\r\n            });\r\n        }\r\n    }\r\n\r\n    // calculates the offset of a thumb in pixels based on its value.\r\n    calcOffset(value) {\r\n        const range = this.props.max - this.props.min;\r\n        if (range === 0) {\r\n            return 0;\r\n        }\r\n        const ratio = (value - this.props.min) / range;\r\n        return ratio * this.state.upperBound;\r\n    }\r\n\r\n    // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\r\n    calcValue(offset) {\r\n        const ratio = offset / this.state.upperBound;\r\n        return ratio * (this.props.max - this.props.min) + this.props.min;\r\n    }\r\n\r\n    calcOffsetFromPosition(position) {\r\n        const { slider } = this;\r\n\r\n        const sliderRect = slider.getBoundingClientRect();\r\n        const sliderMax = sliderRect[this.posMaxKey()];\r\n        const sliderMin = sliderRect[this.posMinKey()];\r\n\r\n        // The `position` value passed in is the mouse position based on the window height.\r\n        // The slider bounding rect is based on the viewport, so we must add the window scroll\r\n        // offset to normalize the values.\r\n        const windowOffset = window[`page${this.axisKey()}Offset`];\r\n        const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\r\n\r\n        let pixelOffset = position - sliderStart;\r\n        if (this.props.invert) {\r\n            pixelOffset = this.state.sliderLength - pixelOffset;\r\n        }\r\n        pixelOffset -= this.state.thumbSize / 2;\r\n        return pixelOffset;\r\n    }\r\n\r\n    // Snaps the nearest thumb to the value corresponding to `position`\r\n    // and calls `callback` with that thumb's index.\r\n    forceValueFromPosition(position, callback) {\r\n        const pixelOffset = this.calcOffsetFromPosition(position);\r\n        const closestIndex = this.getClosestIndex(pixelOffset);\r\n        const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props);\r\n\r\n        // Clone this.state.value since we'll modify it temporarily\r\n        // eslint-disable-next-line zillow/react/no-access-state-in-setstate\r\n        const value = this.state.value.slice();\r\n        value[closestIndex] = nextValue;\r\n\r\n        // Prevents the slider from shrinking below `props.minDistance`\r\n        for (let i = 0; i < value.length - 1; i += 1) {\r\n            if (value[i + 1] - value[i] < this.props.minDistance) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        this.fireChangeEvent('onBeforeChange');\r\n        this.hasMoved = true;\r\n        this.setState({ value }, () => {\r\n            callback(closestIndex);\r\n            this.fireChangeEvent('onChange');\r\n        });\r\n    }\r\n\r\n    // clear all pending timeouts to avoid error messages after unmounting\r\n    clearPendingResizeTimeouts() {\r\n        do {\r\n            const nextTimeout = this.pendingResizeTimeouts.shift();\r\n\r\n            clearTimeout(nextTimeout);\r\n        } while (this.pendingResizeTimeouts.length);\r\n    }\r\n\r\n    start(i, position) {\r\n        const thumbRef = this[`thumb${i}`];\r\n        if (thumbRef) {\r\n            thumbRef.focus();\r\n        }\r\n\r\n        const { zIndices } = this.state;\r\n        // remove wherever the element is\r\n        zIndices.splice(zIndices.indexOf(i), 1);\r\n        // add to end\r\n        zIndices.push(i);\r\n\r\n        this.setState(prevState => ({\r\n            startValue: prevState.value[i],\r\n            startPosition: position !== undefined ? position : prevState.startPosition,\r\n            index: i,\r\n            zIndices,\r\n        }));\r\n    }\r\n\r\n    moveUpByStep(step = this.props.step) {\r\n        const oldValue = this.state.value[this.state.index];\r\n        const newValue = trimAlignValue(oldValue + step, this.props);\r\n        this.move(Math.min(newValue, this.props.max));\r\n    }\r\n\r\n    moveDownByStep(step = this.props.step) {\r\n        const oldValue = this.state.value[this.state.index];\r\n        const newValue = trimAlignValue(oldValue - step, this.props);\r\n        this.move(Math.max(newValue, this.props.min));\r\n    }\r\n\r\n    move(newValue) {\r\n        const { index, value } = this.state;\r\n        const { length } = value;\r\n\r\n        // Short circuit if the value is not changing\r\n        const oldValue = value[index];\r\n        if (newValue === oldValue) {\r\n            return;\r\n        }\r\n\r\n        // Trigger only before the first movement\r\n        if (!this.hasMoved) {\r\n            this.fireChangeEvent('onBeforeChange');\r\n        }\r\n        this.hasMoved = true;\r\n\r\n        // if \"pearling\" (= thumbs pushing each other) is disabled,\r\n        // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\r\n        const { pearling, max, min, minDistance } = this.props;\r\n        if (!pearling) {\r\n            if (index > 0) {\r\n                const valueBefore = value[index - 1];\r\n                if (newValue < valueBefore + minDistance) {\r\n                    // eslint-disable-next-line no-param-reassign\r\n                    newValue = valueBefore + minDistance;\r\n                }\r\n            }\r\n\r\n            if (index < length - 1) {\r\n                const valueAfter = value[index + 1];\r\n                if (newValue > valueAfter - minDistance) {\r\n                    // eslint-disable-next-line no-param-reassign\r\n                    newValue = valueAfter - minDistance;\r\n                }\r\n            }\r\n        }\r\n\r\n        value[index] = newValue;\r\n\r\n        // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\r\n        if (pearling && length > 1) {\r\n            if (newValue > oldValue) {\r\n                this.pushSucceeding(value, minDistance, index);\r\n                trimSucceeding(length, value, minDistance, max);\r\n            } else if (newValue < oldValue) {\r\n                this.pushPreceding(value, minDistance, index);\r\n                trimPreceding(length, value, minDistance, min);\r\n            }\r\n        }\r\n\r\n        // Normally you would use `shouldComponentUpdate`,\r\n        // but since the slider is a low-level component,\r\n        // the extra complexity might be worth the extra performance.\r\n        this.setState({ value }, this.fireChangeEvent.bind(this, 'onChange'));\r\n    }\r\n\r\n    pushSucceeding(value, minDistance, index) {\r\n        let i;\r\n        let padding;\r\n        for (\r\n            i = index, padding = value[i] + minDistance;\r\n            value[i + 1] !== null && padding > value[i + 1];\r\n            i += 1, padding = value[i] + minDistance\r\n        ) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            value[i + 1] = alignValue(padding, this.props);\r\n        }\r\n    }\r\n\r\n    pushPreceding(value, minDistance, index) {\r\n        for (\r\n            let i = index, padding = value[i] - minDistance;\r\n            value[i - 1] !== null && padding < value[i - 1];\r\n            i -= 1, padding = value[i] - minDistance\r\n        ) {\r\n            // eslint-disable-next-line no-param-reassign\r\n            value[i - 1] = alignValue(padding, this.props);\r\n        }\r\n    }\r\n\r\n    axisKey() {\r\n        if (this.props.orientation === 'vertical') {\r\n            return 'Y';\r\n        }\r\n        // Defaults to 'horizontal';\r\n        return 'X';\r\n    }\r\n\r\n    orthogonalAxisKey() {\r\n        if (this.props.orientation === 'vertical') {\r\n            return 'X';\r\n        }\r\n        // Defaults to 'horizontal'\r\n        return 'Y';\r\n    }\r\n\r\n    posMinKey() {\r\n        if (this.props.orientation === 'vertical') {\r\n            return this.props.invert ? 'bottom' : 'top';\r\n        }\r\n        // Defaults to 'horizontal'\r\n        return this.props.invert ? 'right' : 'left';\r\n    }\r\n\r\n    posMaxKey() {\r\n        if (this.props.orientation === 'vertical') {\r\n            return this.props.invert ? 'top' : 'bottom';\r\n        }\r\n        // Defaults to 'horizontal'\r\n        return this.props.invert ? 'left' : 'right';\r\n    }\r\n\r\n    sizeKey() {\r\n        if (this.props.orientation === 'vertical') {\r\n            return 'clientHeight';\r\n        }\r\n        // Defaults to 'horizontal'\r\n        return 'clientWidth';\r\n    }\r\n\r\n    fireChangeEvent(event) {\r\n        if (this.props[event]) {\r\n            this.props[event](prepareOutValue(this.state.value), this.state.index);\r\n        }\r\n    }\r\n\r\n    buildThumbStyle(offset, i) {\r\n        const style = {\r\n            position: 'absolute',\r\n            touchAction: 'none',\r\n            willChange: this.state.index >= 0 ? this.posMinKey() : '',\r\n            zIndex: this.state.zIndices.indexOf(i) + 1,\r\n        };\r\n        style[this.posMinKey()] = `${offset}px`;\r\n        return style;\r\n    }\r\n\r\n    buildTrackStyle(min, max) {\r\n        const obj = {\r\n            position: 'absolute',\r\n            willChange: this.state.index >= 0 ? `${this.posMinKey()},${this.posMaxKey()}` : '',\r\n        };\r\n        obj[this.posMinKey()] = min;\r\n        obj[this.posMaxKey()] = max;\r\n        return obj;\r\n    }\r\n\r\n    buildMarkStyle(offset) {\r\n        return {\r\n            position: 'absolute',\r\n            [this.posMinKey()]: offset,\r\n        };\r\n    }\r\n\r\n    renderThumb = (style, i) => {\r\n        const className = `${this.props.thumbClassName} ${this.props.thumbClassName}-${i} ${\r\n            this.state.index === i ? this.props.thumbActiveClassName : ''\r\n        }`;\r\n\r\n        const props = {\r\n            'ref': r => {\r\n                this[`thumb${i}`] = r;\r\n            },\r\n            'key': `${this.props.thumbClassName}-${i}`,\r\n            className,\r\n            style,\r\n            'onMouseDown': this.createOnMouseDown(i),\r\n            'onTouchStart': this.createOnTouchStart(i),\r\n            'onFocus': this.createOnKeyDown(i),\r\n            'tabIndex': 0,\r\n            'role': 'slider',\r\n            'aria-orientation': this.props.orientation,\r\n            'aria-valuenow': this.state.value[i],\r\n            'aria-valuemin': this.props.min,\r\n            'aria-valuemax': this.props.max,\r\n            'aria-label': Array.isArray(this.props.ariaLabel)\r\n                ? this.props.ariaLabel[i]\r\n                : this.props.ariaLabel,\r\n            'aria-labelledby': Array.isArray(this.props.ariaLabelledby)\r\n                ? this.props.ariaLabelledby[i]\r\n                : this.props.ariaLabelledby,\r\n        };\r\n\r\n        const state = {\r\n            index: i,\r\n            value: prepareOutValue(this.state.value),\r\n            valueNow: this.state.value[i],\r\n        };\r\n\r\n        if (this.props.ariaValuetext) {\r\n            props['aria-valuetext'] =\r\n                typeof this.props.ariaValuetext === 'string'\r\n                    ? this.props.ariaValuetext\r\n                    : this.props.ariaValuetext(state);\r\n        }\r\n\r\n        return this.props.renderThumb(props, state);\r\n    };\r\n\r\n    renderThumbs(offset) {\r\n        const { length } = offset;\r\n\r\n        const styles = [];\r\n        for (let i = 0; i < length; i += 1) {\r\n            styles[i] = this.buildThumbStyle(offset[i], i);\r\n        }\r\n\r\n        const res = [];\r\n        for (let i = 0; i < length; i += 1) {\r\n            res[i] = this.renderThumb(styles[i], i);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    renderTrack = (i, offsetFrom, offsetTo) => {\r\n        const props = {\r\n            key: `${this.props.trackClassName}-${i}`,\r\n            className: `${this.props.trackClassName} ${this.props.trackClassName}-${i}`,\r\n            style: this.buildTrackStyle(offsetFrom, this.state.upperBound - offsetTo),\r\n        };\r\n        const state = {\r\n            index: i,\r\n            value: prepareOutValue(this.state.value),\r\n        };\r\n        return this.props.renderTrack(props, state);\r\n    };\r\n\r\n    renderTracks(offset) {\r\n        const tracks = [];\r\n        const lastIndex = offset.length - 1;\r\n\r\n        tracks.push(this.renderTrack(0, 0, offset[0]));\r\n\r\n        for (let i = 0; i < lastIndex; i += 1) {\r\n            tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\r\n        }\r\n\r\n        tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\r\n\r\n        return tracks;\r\n    }\r\n\r\n    renderMarks() {\r\n        let { marks } = this.props;\r\n\r\n        const range = this.props.max - this.props.min + 1;\r\n\r\n        if (typeof marks === 'boolean') {\r\n            marks = Array.from({ length: range }).map((_, key) => key);\r\n        } else if (typeof marks === 'number') {\r\n            marks = Array.from({ length: range })\r\n                .map((_, key) => key)\r\n                .filter(key => key % marks === 0);\r\n        }\r\n\r\n        return marks\r\n            .map(parseFloat)\r\n            .sort((a, b) => a - b)\r\n            .map(mark => {\r\n                const offset = this.calcOffset(mark);\r\n\r\n                const props = {\r\n                    key: mark,\r\n                    className: this.props.markClassName,\r\n                    style: this.buildMarkStyle(offset),\r\n                };\r\n\r\n                return this.props.renderMark(props);\r\n            });\r\n    }\r\n\r\n    render() {\r\n        const offset = [];\r\n        const { value } = this.state;\r\n        const l = value.length;\r\n        for (let i = 0; i < l; i += 1) {\r\n            offset[i] = this.calcOffset(value[i], i);\r\n        }\r\n\r\n        const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\r\n        const thumbs = this.renderThumbs(offset);\r\n        const marks = this.props.marks ? this.renderMarks() : null;\r\n\r\n        return React.createElement(\r\n            'div',\r\n            {\r\n                ref: r => {\r\n                    this.slider = r;\r\n                    this.resizeElementRef.current = r;\r\n                },\r\n                style: { position: 'relative' },\r\n                className: this.props.className + (this.props.disabled ? ' disabled' : ''),\r\n                onMouseDown: this.onSliderMouseDown,\r\n                onClick: this.onSliderClick,\r\n            },\r\n            tracks,\r\n            thumbs,\r\n            marks\r\n        );\r\n    }\r\n}\r\n\r\nexport default ReactSlider;"]},"metadata":{},"sourceType":"module"}